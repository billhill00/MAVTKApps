#!/usr/bin/python
###
#ident "University of Edinburgh $Id$"
# \file         MAVTKSurfViewer.py
# \author       Bill Hill
# \date         December 2015
# \version      $Id$
# \par
# Address:
#               MRC Human Genetics Unit,
#               MRC Institute of Genetics and Molecular Medicine,
#               University of Edinburgh,
#               Western General Hospital,
#               Edinburgh, EH4 2XU, UK.
# \par
# Copyright (C), [2015],
# The University Court of the University of Edinburgh,
# Old College, Edinburgh, UK.
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be
# useful but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Free
# Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
# Boston, MA  02110-1301, USA.
# \brief        Interactive display of surfaces.
# \ingroup      MAVTKApps
###

from __future__ import print_function

import io
import os
import sys
import json
import math
import time
import argparse
from PyQt4 import Qt, QtCore, QtGui
import vtk
from vtk.qt4.QVTKRenderWindowInteractor import QVTKRenderWindowInteractor

html_page_begin = \
r"""<!DOCTYPE html>
<html lang="en">
<head>
<title>Export from MAVTKSurfViewer</title>
<meta charset="utf-8">
<style>
body {
  font-family      : Monospace;
  background-color : #000;
  color            : #fff;
  margin           : 0px;
  overflow         : hidden;
}
</style>
</head>

<body>
<div id="info">
Export from MAVTKSurfViewer
</div>

<script src="js/three.min.js"></script>
<script src="js/TrackballControls.js"></script>
<script src="js/STLLoader.js"></script>
<script src="js/MAVTKLoader.js"></script>
<script src="js/Detector.js"></script>
<script src="js/MARender.min.js"></script>

<script>
pickHandler = function(e) {
  var txt = 'Objects (front to back):\n';
  for(var i = 0; i < e.hitlist.length; ++i) {
    var hit = e.hitlist[i].object;
    txt = txt + '  ' + hit.name + '\n';
  }
  window.alert(txt);
}

if(!(Detector.webgl)) {
  Detector.addGetWebGLMessage();
}

var container;
container = document.createElement('div');
document.body.appendChild(container);

var ren = new MARenderer(window, container);
ren.init();
"""

html_page_end = \
r"""
ren.addEventListener('pick', pickHandler);
ren.animate();
</script>
</body>
</html>"""

class CameraSettings(): #{
  position = [0.0, 0.0, 0.0]
  focalPoint = [0.0, 0.0, 0.0]
  viewUp = [0.0, 0.0, 0.0]
  viewAngle = 0.0
  parallelScale = 1.0
#}

###
# \class       MAVTKRenderer
# \brief       Provides a single QFrame for rendering using VTK with
#              interaction (default camera trackball) and picker.
###
class MAVTKRenderer(): #{

  def __init__(self): #{
    self.initUI()
  #}
    
  def initUI(self): #{
    self._frame = QtGui.QFrame()
    vl = QtGui.QVBoxLayout()
    self.vtkWidget = QVTKRenderWindowInteractor(self._frame)
    vl.addWidget(self.vtkWidget)
    self._frame.setLayout(vl)
  #}

  def init(self): #{
    self._ren = vtk.vtkRenderer()
    self._picker = vtk.vtkCellPicker()
    self._renWin = self.vtkWidget.GetRenderWindow()
    self._renWin.AddRenderer(self._ren)
    iren  = self._renWin.GetInteractor()
    istyle = vtk.vtkInteractorStyleSwitch()
    iren.SetInteractorStyle(istyle)
    istyle.SetCurrentStyleToTrackballCamera()
    iren.SetPicker(self._picker)
    iren.Initialize()
  #}

  def getIRen(self): #{
    return self._renWin.GetInteractor()
  #}

  def getRenWin(self): #{
    return self._renWin
  #}

  ###
  # \function  getView
  # \brief     Get current camera view.
  ###
  def getView(self): #{
    cam = self._ren.GetActiveCamera()
    v = CameraSettings()
    v.position = cam.GetPosition()
    v.focalPoint = cam.GetFocalPoint()
    v.viewUp = cam.GetViewUp()
    v.viewAngle = cam.GetViewAngle()
    v.parallelScale = cam.GetParallelScale()
    return v

  #}

  ###
  # \function  setView
  # \brief     Set camera view.
  # \param v                 Given camera view.
  ###
  def setView(self, v): #{
    cam = self._ren.GetActiveCamera()
    cam.SetPosition(v.position)
    cam.SetFocalPoint(v.focalPoint)
    cam.SetViewUp(v.viewUp)
    cam.SetViewAngle(v.viewAngle)
    cam.SetParallelScale(v.parallelScale)
    self.Render()
  #}


  def getRen(self): #{
    return self._ren
  #}

  def getPicker(self): #{
    return self._picker
  #}

  def getFrame(self): #{
    return self._frame
  #}

  ###
  # \function  Render
  # \brief     Forces a render update even if the render window doesn't have
  #            focus.
  ###
  def Render(self): #{
   self._renWin.Render()
   self.vtkWidget.update()
 #}

  ###
  # \function  writeFrameToFile
  # \brief     Force a re-rendering and then capture the frame image and
  #            write it to a file with the given path.
  # \param path                File path in which the extension is used to
  #                            determine the image format used.
  ###
  def writeFrameToFile(self, path): #{
    ok = True
    file_type = path.split(".")[-1]
    img = vtk.vtkWindowToImageFilter()
    writer = None
    if file_type == 'bmp': #{
      writer = vtk.vtkBMPWriter()
    elif file_type == 'png': #}{
      writer = vtk.vtkPNGWriter()
    elif file_type == 'pnm' or file_type == 'ppm': #}{
      writer = vtk.vtkPNMWriter()
    elif file_type == 'tif' or file_type == 'tiff': #}{
      writer = vtk.vtkTIFFWriter()
    #}
    if(writer): #{
      img.SetInput(self._renWin)
      writer.SetInputConnection(img.GetOutputPort())
      writer.SetFileName(str(path))
      self._ren.Render()
      writer.Write()
    else: #}{
      ok = False
      result = QtGui.QMessageBox.critical(self._frame,
                   'Error',
                   'Unsupported file format (' + str(file_type) + ').',
                   QtGui.QMessageBox.Close)
    #}
    return not ok
  #}
#}

###
# \class       MAVTKActorTable
# \brief       Inherits from QDialog and contains a QTableWidget which is
#              used to display and interact with actor properties.
###
class MAVTKActorTable(QtGui.QDialog): #{

  colorChangeSignal = QtCore.pyqtSignal(int, Qt.QColor)
  opacityChangeSignal = QtCore.pyqtSignal(int, float)
  visableChangeSignal = QtCore.pyqtSignal(int, bool)

  def __init__(self): #{
    super(MAVTKActorTable, self).__init__()
    self._tableDict = {'Index'   : 0,
                       'Visible' : 1,
                       'Name'    : 2,
                       'Color'   : 3,
                       'Opacity' : 4,
                       'Path'    : 5}
    self._tableKeys = ['Index', 'Visible', 'Name', 'Color', 'Opacity', 'Path']
    self._actors = []
    self.initUI()
  #}

  def initUI(self): #{
    self.setWindowTitle('Actor Table')
    self. setMinimumWidth(600)
    vl = QtGui.QVBoxLayout()
    self.setLayout(vl)
    self._table = QtGui.QTableWidget(0, 6)
    vl.addWidget(self._table)
    but = QtGui.QDialogButtonBox(
              QtGui.QDialogButtonBox.Cancel,
              QtCore.Qt.Horizontal, self)
    but.rejected.connect(self.cancel)
    vl.addWidget(but)
    self._table.setSizePolicy(QtGui.QSizePolicy.Expanding,
                             QtGui.QSizePolicy.Expanding)
    self._table.verticalHeader().setVisible(False)
    self._table.horizontalHeader().setStretchLastSection(True)
    self._table.setHorizontalHeaderLabels(self._tableKeys)
    self._table.cellClicked.connect(self.cellClicked)
    self._table.cellChanged.connect(self.cellChanged)
    self._table.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
  #}

  def cancel(self): #{
    self.hide()
  #}

  def textToFloat(self, txt): #{
    try: #{
      val = float(txt)
      if(val < 0.0):
        val = 0.0
      elif(val > 1.0):
        val = 1.0
    except ValueError: #}{
      val = 0.0
    #}
    return val
  #}

  ###
  # \function  delActor
  # \brief     Not implemented. There is currently no actor deletion,
  #            this allows simple index based actor selection
  ###
  def delActor(self, idx): #{
    print('delActor() - not implemented', file=sys.stderr)
  #}

  def addActor(self, actor, visible, name, color, opacity, path): #{
    idx = len(self._actors)
    self._actors.insert(idx, actor)
    self._table.insertRow(idx)
    self._setActorIndex(idx)
    self._setActorName(idx, name)
    self.setActorColor(idx, color)
    self.setActorOpacity(idx, opacity)
    self.setActorPath(idx, path)
    self.setActorVisible(idx, visible)
  #}

  ###
  # \function  _setActorIndex
  # \brief     Sets the index in the table.
  # \param idx                 Given index.
  ###
  def _setActorIndex(self, idx): #{
    itm = QtGui.QTableWidgetItem(str(idx))
    itm.setFlags(itm.flags() & (~QtCore.Qt.ItemIsEditable))
    self._table.setItem(idx, self._tableDict['Index'], itm)
  #}

  ###
  # \function  setActorVisible
  # \brief     Sets actor visability in the table.
  # \param idx                 Given index.
  # \param state               actor visability (boolean).
  ###
  def setActorVisible(self, idx, state): #{
    itm = QtGui.QTableWidgetItem(str(state))
    itm.setFlags(itm.flags() & (~QtCore.Qt.ItemIsEditable))
    self._table.setItem(idx, self._tableDict['Visible'], itm)
  #}

  ###
  # \function  _setActorName
  # \brief     Sets the actor name for the given index in the table.
  # \param idx                 Given index.
  # \param name                Given actor name to set.
  ###
  def _setActorName(self, idx, name): #{
    itm = QtGui.QTableWidgetItem(name)
    self._table.setItem(idx, self._tableDict['Name'], itm)
  #}

  ###
  # \function  setActorColor
  # \brief     Sets the actor colour for the given index in the table.
  # \param idx                 Given index.
  # \param name                Given actor colour as a QColor.
  ###
  def setActorColor(self, idx, color): #{
    itm = QtGui.QTableWidgetItem()
    itm.setBackgroundColor(color)
    itm.setFlags(itm.flags() & (~QtCore.Qt.ItemIsEditable))
    self._table.setItem(idx, self._tableDict['Color'], itm)
  #}

  ##
  # \function  
  # \brief     Sets the actor opacity for the given index in the table.
  # \param idx                 Given index.
  # \param opacity             Given actor opacity.
  ###
  def setActorOpacity(self, idx, opacity): #{
    setval = not bool(self._table.item(idx, self._tableDict['Opacity']))
    if(not setval): #{
      txt = self._table.item(idx, self._tableDict['Opacity']).text()
      val = self.textToFloat(txt)
      if(math.fabs(val - opacity) >= 0.0001): #{
        opacity = val
        setval = true
      #}
    #}
    if(setval): #{
      itm = QtGui.QTableWidgetItem(str(opacity))
      self._table.setCellWidget(idx, self._tableDict['Opacity'], None)
      self._table.setItem(idx, self._tableDict['Opacity'], itm)
    #}
  #}

  ##
  # \function  
  # \brief     Sets the actor file path for the given index in the table.
  # \param idx                 Given index.
  # \param path                Given actor file path.
  ###
  def setActorPath(self, idx, path): #{
    itm = QtGui.QTableWidgetItem(path)
    itm.setFlags(itm.flags() & (~QtCore.Qt.ItemIsEditable))
    self._table.setItem(idx, self._tableDict['Path'], itm)
  #}

  def selectActor(self, idx): #{
    self._table.selectRow(idx)
  #}

  def getNumActors(self): #{
    return self._table.rowCount()
  #}

  def getActor(self, idx): #{
    actor = self._actors[idx]
    return actor
  #}

  def getActorVisability(self, idx): #{
    vis = 'True' == \
          str(self._table.item(idx, self._tableDict['Visible']).text())
    return vis
  #}

  def getActorName(self, idx): #{
    name = str(self._table.item(idx, self._tableDict['Name']).text())
    return name
  #}

  def getActorColor(self, idx): #{
    q_col = self._table.item(idx, self._tableDict['Color']).backgroundColor()
    return q_col
  #}

  def getActorOpacity(self, idx): #{
    opacity = float(self._table.item(idx, self._tableDict['Opacity']).text())
    return opacity
  #}

  def getActorPath(self, idx): #{
    path = str(self._table.item(idx, self._tableDict['Path']).text())
    return path
  #}

  def cellClicked(self, idx, prop): #{
    if prop == self._tableDict['Visible']: #{
      vis = not self.getActorVisability(idx)     
      self.visableChangeSignal.emit(idx, vis)
    elif prop == self._tableDict['Color']: #}{
      col = QtGui.QColorDialog.getColor()
      if col.isValid(): #{
        self.colorChangeSignal.emit(idx, col)
      #}
    #}
  #}

  def cellChanged(self, idx, prop): #{
    if prop == self._tableDict['Opacity']: #{
      txt = self._table.item(idx, prop).text()
      val = self.textToFloat(txt)
      self.opacityChangeSignal.emit(idx, val)
    #}
  #}
#}


###
# \class       AboutDialog
# \brief       A dialog descended from QDialog which shows basic information
#              about the application.
###
class AboutDialog(QtGui.QDialog): #{

  def __init__(self, version, parent = None): #{
    super(AboutDialog, self).__init__(parent)
    self.initUI(version)
  #}

  def initUI(self, version): #{
    msg = '<b>MAVTKSurfViewer</b>' + \
          '<p>Version ' + version + '.</p>' + \
          '<p>A VTK based multiple surface viewer.</p>' + \
          '<p>ma-tech@igmm.ed.ac.uk</p>'
    lo = QtGui.QVBoxLayout(self)
    txt = QtGui.QLabel(msg)
    lo.addWidget(txt)
    but = QtGui.QDialogButtonBox(
              QtGui.QDialogButtonBox.Cancel,
              QtCore.Qt.Horizontal, self)
    but.rejected.connect(self.cancel)
    lo.addWidget(but)
  #}

  def cancel(self): #{
    self.hide()
  #}
#}
    
###
# \class       ControlsDialog
# \brief       A dialog descended from QDialog which shows basic controls
#              of the render window.
###
class ControlsDialog(QtGui.QDialog): #{

  def __init__(self, parent = None): #{
    super(ControlsDialog, self).__init__(parent)
    self.initUI()
  #}

  def initUI(self): #{
    msg = '<b>MAVTKSurfViewer Interactive Controls</b>' + \
    '<br>' + \
    '<p>The visualisation can be controlled by a set of keyboard ' + \
    'and mouse actions which are common across most VTK based ' + \
    'applications</p>' + \
    '<br>' + \
    '<p><table>' + \
    '<tr><td>Key a</td><td> - manipulate the actor</td></tr>' + \
    '<tr><td>Key c</td><td> - manipulate the camera</td></tr>' + \
    '<tr><td>Key j</td><td> - joystick manipulation mode</td></tr>' + \
    '<tr><td>Key t</td><td> - trackball manipulation mode</td></tr>' + \
    '<tr><td>Key p</td><td> - pick actor</td></tr>' + \
    '<tr><td>Key s</td><td> - solid surfaces</td></tr>' + \
    '<tr><td>Key w</td><td> - wireframe surfaces</td></tr>' + \
    '<tr><td>Key 3</td><td> - toggle 3D stereo</td></tr>' + \
    '<tr><td>Button 1</td><td> - rotate</td></tr>' + \
    '<tr><td>Button 2</td><td> - pan</td></tr>' + \
    '<tr><td>Button 3</td><td> - zoom</td></tr>' + \
    '<tr><td>Ctrl-Button 1</td><td> - spin</td></tr>' + \
    '<tr><td>Ctrl-Button 2</td><td> - dolly</td></tr>' + \
    '</table></p>' + \
    '<p>Camera mode, trackball mode and solid surfaces are the defaults ' + \
    'used.</p>'
    lo = QtGui.QVBoxLayout(self)
    txt = QtGui.QLabel(msg)
    lo.addWidget(txt)
    but = QtGui.QDialogButtonBox(
              QtGui.QDialogButtonBox.Cancel,
              QtCore.Qt.Horizontal, self)
    but.rejected.connect(self.cancel)
    lo.addWidget(but)
  #}

  def cancel(self): #{
    self.hide()
  #}
#}
    

###
# \class       MovieCreationState
# \brief       Class used for an enum with movie creation states.
###
class MovieCreationState(object): #{
  stop  = 0
  run   = 1
#}

class MovieCreationDialog(QtGui.QDialog): #{
  _current_path = ''

  def __init__(self, parent = None): #{
    super(MovieCreationDialog, self).__init__(parent)
    self.initUI()
    self._state = MovieCreationState.stop
  #}

  def initUI(self): #{
    lov = QtGui.QVBoxLayout(self)
    fr_main = QtGui.QFrame()
    buttons = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Cancel,
                  QtCore.Qt.Horizontal, self)
    lov.addWidget(fr_main)
    lov.addWidget(buttons)
    loh  = QtGui.QHBoxLayout()
    fr_main.setLayout(loh)
    fr_fxr  = QtGui.QFrame()
    fr_ctl  = QtGui.QFrame()
    loh.addWidget(fr_fxr)
    loh.addWidget(fr_ctl)
    lo_fxr  = QtGui.QGridLayout(fr_fxr)
    lo_ctl  = QtGui.QGridLayout(fr_ctl)
    lb_fxr = QtGui.QLabel('Fixed Rotations')
    lb_fxr.setAlignment(QtCore.Qt.AlignCenter)
    lo_fxr.addWidget(lb_fxr, 0, 0, 1, 4)
    lb_nos = QtGui.QLabel('Number of Steps')
    lb_nos.setAlignment(QtCore.Qt.AlignLeft)
    lo_fxr.addWidget(lb_nos, 1, 0, 1, 2)
    self._sp_nos = QtGui.QSpinBox()
    self._sp_nos.setRange(0, 99999999)
    self._sp_nos.setValue(0)
    lo_fxr.addWidget(self._sp_nos, 1, 3, 1, 1)
    lb_dps = QtGui.QLabel('Degrees per Step')
    lb_dps.setAlignment(QtCore.Qt.AlignLeft)
    lo_fxr.addWidget(lb_dps, 2, 0, 1, 2)
    self._sp_dps = QtGui.QSpinBox()
    self._sp_dps.setRange(-359, 359)
    self._sp_dps.setValue(0)
    lo_fxr.addWidget(self._sp_dps, 2, 3, 1, 1)
    lb_axis = QtGui.QLabel('Axis')
    lb_axis.setAlignment(QtCore.Qt.AlignLeft)
    lo_fxr.addWidget(lb_axis, 3, 0, 1, 2)
    self._cb_axis = QtGui.QComboBox()
    self._cb_axis.addItems(['X', 'Y', 'Z'])
    lo_fxr.addWidget(self._cb_axis, 3, 2, 1, 2)
    lb_ctl = QtGui.QLabel('Movie Controls')
    lb_ctl.setAlignment(QtCore.Qt.AlignCenter)
    lo_ctl.addWidget(lb_ctl, 0, 0, 1, 4)
    lb_file = QtGui.QLabel('Base file name')
    lb_file.setAlignment(QtCore.Qt.AlignLeft)
    lo_ctl.addWidget(lb_file, 1, 0, 1, 2)
    bt_file = QtGui.QPushButton('Browse ...')
    lo_ctl.addWidget(bt_file, 1, 3, 1, 1)
    self._le_path = QtGui.QLineEdit('no file')
    lo_ctl.addWidget(self._le_path, 2, 0, 1, 4)
    lb_fix = QtGui.QLabel('File index')
    lb_fix.setAlignment(QtCore.Qt.AlignLeft)
    lo_ctl.addWidget(lb_fix, 3, 0, 1, 2)
    self._sp_fix = QtGui.QSpinBox()
    self._sp_fix.setRange(0, 99999999)
    self._sp_fix.setValue(0)
    lo_ctl.addWidget(self._sp_fix, 3, 2, 1, 2)
    self._bt_start = QtGui.QPushButton('Start')
    lo_ctl.addWidget(self._bt_start, 4, 0, 1, 2)
    self._bt_stop = QtGui.QPushButton('Stop')
    lo_ctl.addWidget(self._bt_stop, 4, 2, 1, 2)
    bt_file.clicked.connect(self.selectFile)
    buttons.rejected.connect(self.cancel)
  #}

  def cancel(self): #{
    self.hide()
  #}

  def setStateRun(self): #{
    self._state = MovieCreationState.run
  #}

  def setStateStop(self): #{
    self._state = MovieCreationState.stop
  #}

  ###
  # \function  stateIsStop
  # \brief     Checks the value of the movie creation state flag, but before
  #            doing this makes sure that any Qt events have been processed.
  ###
  def stateIsStop(self): #{
    QtGui.QApplication.processEvents()
    return self._state == MovieCreationState.stop
  #}

  def selectFile(self): #{
    path = QtGui.QFileDialog.getOpenFileName(self, 'Select base movie file',
               self._current_path,
               'Image files (*.bmp *.png *.pnm *.tif *.tiff);;' +
               'All files (*)')
    if(path): #{
      self._le_path.setText(path)
    #}
  #}
  
  def getNumStep(self): #{
    return self._sp_nos.value()
  #}

  def getDegPerStep(self): #{
    return self._sp_dps.value()
  #}

  def getAxis(self): #{
    return str(self._cb_axis.currentText())
  #}

  def getFilename(self): #{
    path = str(self._le_path.text())
    if path == 'no file': #{
      path = None
    #}
    return path
  #}

  def getFileIndex(self): #{
    return self._sp_fix.value()
  #}

  def setFileIndex(self, value): #{
    self._sp_fix.setValue(value)
  #}

  def incFileIndex(self): #{
    self._sp_fix.setValue(self._sp_fix.value() + 1)
  #}

  def getStartPB(self): #{
    return self._bt_start
  #}

  def getStopPB(self): #{
    return self._bt_stop
  #}
#}


###
# \class       MAVTKSurfViewer
# \brief       Main window of the application descended from QMainWindow.
#              This has a menu bar, render window and status bar.
###
class MAVTKSurfViewer(QtGui.QMainWindow): #{
  _version = '1.0.0'
  _actor_file_ident = 'MAVTKSurfViewer Actor Settings'
  _file_formats = ['obj', 'stl', 'vtk']
  _animation = 0
  _home = None
  _movie = None

  def __init__(self, files): #{
    super(MAVTKSurfViewer, self).__init__()
    self._current_path = ''
    self._def_opacity = 1.0
    self._def_color = [1.0, 1.0, 1.0]
    self.initUI(files)
  #}

  def initUI(self, files): #{
    iCol = [1.0, 1.0, 1.0]
    ## Actor table
    self._actors = MAVTKActorTable()
    ### Menubar
    menubar = self.menuBar()
    fMenu = menubar.addMenu('&File')
    aMenu = menubar.addMenu('&Actions')
    vMenu = menubar.addMenu('&View')
    menubar.addSeparator()
    hMenu = menubar.addMenu('&Help')
    ## 
    fOpen = QtGui.QAction(QtGui.QIcon('open.png'), 'Open', self)
    fOpen.setShortcut('Ctrl+O')
    fOpen.setStatusTip('Open new surface file')
    fOpen.triggered.connect(self.openFile)
    fMenu.addAction(fOpen)
    # 
    fSaveImage = QtGui.QAction(QtGui.QIcon('save.png'), 'Save Image', self)
    fSaveImage.setShortcut('Ctrl+I')
    fSaveImage.setStatusTip('Save rendered image')
    fSaveImage.triggered.connect(self.saveImage)
    fMenu.addAction(fSaveImage)
    # 
    fSaveActors = QtGui.QAction(QtGui.QIcon('save.png'), \
                                'Save Actor Settings', self)
    fSaveActors.setStatusTip('Save actor settings')
    fSaveActors.triggered.connect(self.saveActors)
    fMenu.addAction(fSaveActors)
    #
    fExportActorsForWeb = QtGui.QAction(QtGui.QIcon('save.png'), \
                                  'Export Actors as Web Page', self)
    fExportActorsForWeb.setStatusTip('Export Actors as Web Page')
    fExportActorsForWeb.triggered.connect(self.exportActorsForWeb)
    fMenu.addAction(fExportActorsForWeb)
    # 
    fExportActorsForMARV = QtGui.QAction(QtGui.QIcon('save.png'), \
                           'Export Actors as MARenderView config', self)
    fExportActorsForMARV.setStatusTip('Export Actors as MARenderView config')
    fExportActorsForMARV.triggered.connect(self.exportActorsForMARV)
    fMenu.addAction(fExportActorsForMARV)
    #
    fLoadActors = QtGui.QAction(QtGui.QIcon('save.png'), \
                                'Load Actor Settings', self)
    fLoadActors.setStatusTip('Load actor settings')
    fLoadActors.triggered.connect(self.loadActors)
    fMenu.addAction(fLoadActors)
    #
    fExit  = QtGui.QAction(QtGui.QIcon('exit.png'), 'Exit', self)
    fExit.setShortcut('Ctrl+Q')
    fExit.setStatusTip('Exit Application')
    fExit.triggered.connect(self.quit)
    fMenu.addAction(fExit)
    ##
    self._movie = MovieCreationDialog()
    aMovie = QtGui.QAction('Create Movie', self)
    aMovie.setShortcut('Ctrl+M')
    aMovie.setStatusTip('Open movie creation dialog')
    aMovie.triggered.connect(self.createMovie)
    aMenu.addAction(aMovie)
    self._movie.getStartPB().clicked.connect(self.movieStart)
    self._movie.getStopPB().clicked.connect(self.movieStop)
    ##
    vSetBackground = QtGui.QAction('Set Background', self)
    vSetBackground.setShortcut('Ctrl+B')
    vSetBackground.setStatusTip('Set render window background colour')
    vSetBackground.triggered.connect(self.setBackground)
    vMenu.addAction(vSetBackground)
    #
    vShowTable = QtGui.QAction('Show Actor Table', self)
    vShowTable.setShortcut('Ctrl+T')
    vShowTable.setStatusTip('Show actor table')
    vShowTable.triggered.connect(self.showTable)
    vMenu.addAction(vShowTable)
    #
    vGoHome = QtGui.QAction('Go Home', self)
    vGoHome.setShortcut('Ctrl+H')
    vGoHome.setStatusTip('Go to home view')
    vGoHome.triggered.connect(self.goHome)
    vMenu.addAction(vGoHome)
    #
    vSetHome = QtGui.QAction('Set Home', self)
    vSetHome.setShortcut('Ctrl+H')
    vSetHome.setStatusTip('Set home view')
    vSetHome.triggered.connect(self.setHome)
    vMenu.addAction(vSetHome)
    #
    vViewAll = QtGui.QAction('View All', self)
    vViewAll.setShortcut('Ctrl+R')
    vViewAll.setStatusTip('View all actors')
    vViewAll.triggered.connect(self.resetView)
    vMenu.addAction(vViewAll)
    ##
    self.controls = ControlsDialog()
    hControls = QtGui.QAction(QtGui.QIcon('help.png'), 'Controls', self)
    hControls.setStatusTip('Interactive controls')
    hControls.triggered.connect(self.showControls)
    hMenu.addAction(hControls)
    #
    self.about = AboutDialog(self._version)
    hAbout = QtGui.QAction(QtGui.QIcon('help.png'), 'About', self)
    hAbout.setStatusTip('About MAVTKSurfViewer')
    hAbout.triggered.connect(self.showAbout)
    hMenu.addAction(hAbout)
    #
    self.statusBar()
    self.setGeometry(256, 256, 768, 768)
    self.setWindowTitle('MAVTKSurfViewer')
    #
    self._actors.visableChangeSignal.connect(self.setActorVisible)
    self._actors.colorChangeSignal.connect(self.setActorColor)
    self._actors.opacityChangeSignal.connect(self.setActorOpacity)
    #
    self.ren = MAVTKRenderer()
    self.setCentralWidget(self.ren.getFrame())
    self.show()
    self.ren.init()
    # Read files given on command line
    r = 4203829009 # seed for an OK sequence of colors
    for f in files: #{
      self.addSurf(True, os.path.basename(f), iCol, self._def_opacity, f)
      r = self._getRandomColor(r, iCol)
    #}
    # Add pick observer
    self.ren.getPicker().AddObserver("EndPickEvent", self.cellPicked)
    # Reset the camera to view all
    self.ren.getRen().ResetCamera()
  #}

  ###
  # \function  _getRandomColor
  # \brief     Gets a random colour as a VTK tripple float colour array.
  #            The previous value is used to ensure a repeatable random
  #            sequence. The values selected use a basic Lehmer random number
  #            generator but the values are constrained a little to avoid
  #            almost black or almost white colours.
  # \return    Value used to ensure repeatable sequence.
  # \param r                   Previous value returned.
  # \param cols                Array of three floats for VTK colours, set
  #                            on return.
  ###
  def _getRandomColor(self, r, cols): #{
    d = 0.0
    e = 0.0
    while (d < 1.0) and ((e < 1.0) or (e > 2.0)): #{
      d = 0.0
      e = 0.0
      for i in range(0,3): #{
        if r == 0: #{
          r = 255
        else: #}{
          r = (r * 279470273) % 4294967291
        #}
        c = float(r & 255) / 255.0
        d = d + math.fabs(c - cols[i])
        e = e + c
        cols[i] = c
      #}
    #}
    return r
  #}

  def quit(self): #{
    sys.exit(0)
  #}


  def showAbout(self): #{
    self.about.show()
  #}

  def showControls(self): #{
    self.controls.show()
  #}

  def cellPicked(self, object, event): #{
    picker = self.ren.getPicker()
    pt = picker.GetPointId()
    cell = picker.GetCellId()
    pos = picker.GetPickPosition()
    print(pt)
    print(cell)
    print(pos)
    self.statusBar().showMessage('Pick: point = ' + str(pt) + \
                                 ', cell = ' + str(cell) + \
                                 ', pos = ' + str(pos))
    if picker.GetCellId() >= 0: #{
      pActor = picker.GetActor();
      actorArray = self._actors._actors
      for idx in range(0, len(actorArray)): #{
        if actorArray[idx] == pActor: #{
          self._actors.selectActor(idx)
        #}
      #}
    #}
  #}

  ###
  # \function  addSurf
  # \brief     Adds a surface to the viewer.
  # \param visible             Actor visibility (boolean).
  # \param name                Actor name.
  # \param v_col               Actor colour as a VTK triple float array.
  # \param opacity             Actor opacity as a float with range [0.0-1.0].
  # \param path                Actor file path.
  ### 
  def addSurf(self, visible, name, v_col, opacity, path): #{
    reader = None
    file_type = path.split(".")[-1]
    if file_type in self._file_formats: #{
      if file_type == 'obj': #{
        reader = vtk.vtkOBJReader()
      elif file_type == 'stl': #}{
        reader = vtk.vtkSTLReader()
      elif file_type == 'vtk': #}{
        reader = vtk.vtkPolyDataReader()
    #}
    reader.SetFileName(path)
    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputConnection(reader.GetOutputPort())
    actor = vtk.vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetOpacity(opacity)
    actor.GetProperty().SetDiffuseColor(v_col)
    actor.GetProperty().SetAmbient(0.2);
    actor.GetProperty().SetDiffuse(0.6);
    actor.GetProperty().SetSpecular(0.2);
    actor.GetProperty().SetSpecularPower(3.0);
    actor.SetVisibility(int(visible))
    self.ren.getRen().AddActor(actor)
    self.ren.Render()
    q_col = Qt.QColor(255 * v_col[0], 255 * v_col[1], 255 * v_col[2])
    self._actors.addActor(actor, visible, name, q_col, opacity, path)
  #}

  ###
  # \function  openFile
  # \brief     Opens a file, reads a surface and adds an actor for it.
  ###
  def openFile(self): #{
    c = ''
    s = 'Surface files ('
    for f in self._file_formats:
      s = s + c + '*.' + f
      c = ' '
    s = s + ');; All files (*)'
    path = QtGui.QFileDialog.getOpenFileName(self, 'Open surface file',
               self._current_path, s)
    if(path): #{
      p = str(path)
      self.addSurf(True, os.path.basename(p), self._def_color, 
                   self._def_opacity, p)
    #}
  #}

  ###
  # \function  saveImage
  # \brief     Prompts for file path using a QFileDialog and then saves
  #            the current rendered image to the file.
  ###
  def saveImage(self): #{
    path = QtGui.QFileDialog.getSaveFileName(self, 'Write rendered image',
               self._current_path,
               'Image files (*.bmp *.png *.pnm *.tif *.tiff);;' +
               'All files (*)')
    if(path): #{
      if not self.ren.writeFrameToFile(path):
        QtGui.QMessageBox.critical(self.frame,
                   'Error',
                   'Failed to write image to file ' + path + '.',
                   QtGui.QMessageBox.Close)
    #}
  #}

  ###
  # \function  saveActors
  # \brief     Prompts for a file path and then saves the current actor
  #            settings to the file. The settings are saved using a json
  #            dump.
  ###
  def saveActors(self): #{
    path = QtGui.QFileDialog.getSaveFileName(self, 'Write actor settings',
               self._current_path,
               'Actor settings files (*.jsn *.json);;All files (*)')
    n_act = self._actors.getNumActors()
    act_ary = []
    for idx in range(0, n_act): #{
      col = self._actors.getActorColor(idx)
      act_ary.append( \
        { \
          'visible' : self._actors.getActorVisability(idx), \
          'name': self._actors.getActorName(idx), \
          'color': [col.red(), col.blue(), col.green()], \
          'opacity': self._actors.getActorOpacity(idx), \
          'path': self._actors.getActorPath(idx) \
        })
    #}
    data = { \
      'ident': self._actor_file_ident, \
      'version': self._version, \
      'num_actors': n_act, \
      'actors': act_ary
      }
    if(path): #{
      try: #{
        f = io.open(str(path), 'w', encoding='utf-8')
        f.write(unicode(json.dumps(data)))
        f.close()
      except: #}{
        QtGui.QMessageBox.critical(self,
            'Error',
            'Failed to write actor setting to file ' + path + '.',
            QtGui.QMessageBox.Close)
      #}
    #}
  #}

  ###
  # \function exportActorsForWeb
  # \brief    Prompts for a file path and then exports the current actor
  #           settings to a web page which uses MARender and three.js
  ###
  def exportActorsForWeb(self): #{
    path = QtGui.QFileDialog.getSaveFileName(self,
               'Export actors for web page',
               self._current_path,
               'HTML files (*.html);;All files (*)')
    page_text = html_page_begin
    n_act = self._actors.getNumActors()
    for idx in range(0, n_act): #{
      if self._actors.getActorVisability(idx): #{
        col = self._actors.getActorColor(idx)
        page_text = page_text + \
                    'ren.addModel({name:        \'' + \
                    self._actors.getActorName(idx) + '\',\n' + \
                    '              path:        \'' + \
                    self._actors.getActorPath(idx) + '\',\n' + \
                    '              transparent: true,\n' + \
                    '              opacity:     ' + \
                    str(self._actors.getActorOpacity(idx)) + ',\n' + \
                    '              color:       0x' + \
                    col.name()[1:] + ',\n' + \
                    '              mode:        MARenderMode.PHONG});\n'
      #}
    #}
    page_text = page_text + html_page_end
    try: #{
      f = io.open(str(path), 'w')
      f.write(unicode(page_text))
      f.close()
    except: #}{
        QtGui.QMessageBox.critical(self,
            'Error',
            'Failed to export actors as web page file ' + path + '.',
            QtGui.QMessageBox.Close)
      #}
  #}

  ###
  # \function exportActorsForWeb
  # \brief    Prompts for a file path and then exports the current actor
  #           settings to a json MARenderView configuration file.
  ###
  def exportActorsForMARV(self): #{
    path = QtGui.QFileDialog.getSaveFileName(self,
               'Export actors for MARenderView',
               self._current_path,
               'Json files (*.jsn *.json);;All files (*)')
    n_act = self._actors.getNumActors()
    section_view = { \
                     'dst': 0, \
                     'pit': 0, \
                     'yaw': 0, \
                     'fxp': {'x' : 0, 'y': 0, 'z': 0}
                   }
    section = { \
                'idx': 0, \
                'name': 'section', \
                'transparent': True, \
                'color': '0xffffff', \
                'opacity': 1.0, \
                'wlz': 'null'
              }
    domains = []
    for idx in range(0, n_act): #{
      if self._actors.getActorVisability(idx): #{
        col = self._actors.getActorColor(idx)
        trans = ((self._actors.getActorOpacity(idx) + 0.0001) < 1.0);
        hexcol = '0x' + str(col.name()[1:])
        domains.append( \
          { \
            'idx' : idx, \
            'name': self._actors.getActorName(idx), \
            'path': self._actors.getActorPath(idx), \
            'transparent': trans, \
            'color': hexcol, \
            'opacity': self._actors.getActorOpacity(idx)
          })
      #}
    #}
    config = { \
      'title': 'Export from VAVTKSurfViewer', \
      'info': 'Export from VAVTKSurfViewer (version ' + \
              self._version + ').', \
      'iip3dsrv': 'http://localhost/fcgi-bin/wlziipsrv.fcgi', \
      'show_gui': True,
      'section_view': section_view, \
      'section': section, \
      'domains': domains
      }
    if(path): #{
      try: #{
        f = io.open(str(path), 'w', encoding='utf-8')
        f.write(unicode(json.dumps(config)))
        f.close()
      except: #}{
        QtGui.QMessageBox.critical(self,
            'Error',
            'Failed to write MARenderView config to file ' + \
            path + '.',
            QtGui.QMessageBox.Close)
      #}
    #}
  #}

  ###
  # \function  loadActors
  # \brief     Prompts for a file path and then reads acor settings from the
  #            file, where these have been saved using the json format of
  #            saveActors(). The actors are added and do not replace existing
  #            actors.
  ###
  def loadActors(self): #{
    path = QtGui.QFileDialog.getOpenFileName(self, 'Load actor settings',
               self._current_path,
               'Json files (*.jsn *.json);;All files (*)')
    if(path): #{
      n_act = 0
      data = None
      try: #{
        f = io.open(str(path), 'r')
        data = json.load(f)
        f.close()
        if bool(data): #{
          n_act = int(data['num_actors'])
          if (not str(data['ident']) == self._actor_file_ident) or \
             (n_act < 0): #{
            data = None
          #}
        #}
      except: #}{
        data = None
      #}
      if bool(data): #{
        act_ary = data['actors']
        for idx in range(0, n_act): #{
          act = act_ary[idx]
          try: #{
            name = str(act['name'])
          except: #}{
            name = str(idx)
          #}
          try: #{
            col = act['color']
            v_col = [float(col[0]) / 255.0, \
                     float(col[1]) / 255.0, \
                     float(col[2]) / 255.0]
          except: #}{
            v_col = [1.0, 1.0, 1.0]
          #}
          try: #{
            visible = bool(act['visible'])
          except: #}{
            visible = True
          #}
          try: #{
            opacity = float(act['opacity'])
          except: #}{
            opacity = 1.0
          #}
          path = str(act['path'])
          self.addSurf(visible, name, v_col, opacity, path)
        #}
      #}
      if not bool(data): #{
        QtGui.QMessageBox.critical(self,
            'Error',
            'Failed to write actor setting to file ' + path + '.',
            QtGui.QMessageBox.Close)
               
      #}
    #}
  #}

  def getNumActors(self): #{
    return self._table.rowCount()
  #}

  def getActor(self, idx): #{
    actor = self._actors[idx]
    return actor
  #}

  def getActorName(self, idx): #{
    name = str(self._table.item(idx, self.tableDict['Name']).text())
    return name
  #}

  def getActorColor(self, idx): #{
    q_col = self._table.item(idx, self.tableDict['Color']).backgroundColor()
    return q_col
  #}

  def getActorOpacity(self, idx): #{
    opacity = float(self._table.item(idx, self.tableDict['Opacity']).text())
    return opacity
  #}

  def getActorPath(self, idx): #{
    path = str(self._table.item(idx, self.tableDict['Path']).text())

  def createMovie(self): #{
    self._movie.show()
  #}

  ###
  # \function  movieStop
  # \brief     Stop any movie creation by setting a flag.
  ###
  def movieStop(self): #{
    self._movie.setStateStop()
  #}

  ###
  # \function  animationLoop
  # \brief     Renders a single frame of a movie, saves it to a file and
  #            then checks for a flag set to destroy the timer which
  #            might call this function.
  ###
  def animationLoop(self, object, event): #{
    self.ren.Render()
    self.saveMovieFrame()
    if self._movie.stateIsStop(): #{
      self.ren.getIRen().DestroyTimer(self._animation)
    #}
  #}

  ###
  # \function  movieStart
  # \brief     Starts creating movie images.
  #            If the number of steps is greater than zero then the
  #            fixed animation is run, otherwise frames are stored as
  #            rendered until the movie creation process is stopped.
  ###
  def movieStart(self): #{
    img = vtk.vtkWindowToImageFilter()
    if self._movie.stateIsStop(): #{
      self._movie.setStateRun()
      cam = self.ren.getRen().GetActiveCamera()
      rot = self._movie.getDegPerStep()
      axis = self._movie.getAxis()
      nSteps = self._movie.getNumStep()
      if nSteps > 0: #{
        for step in range(0, nSteps): #{
          if axis == 'X': #{
            cam.Elevation(rot)
          elif axis == 'Y': #}{
            cam.Azimuth(rot)
          else: # axis == 'Z' #}{
            cam.Roll(rot)
          #}
          cam.OrthogonalizeViewUp()
          self.ren.Render()
          self.saveMovieFrame()
          if self._movie.stateIsStop(): #{
            break
          #}
        #}
        if not self._movie.stateIsStop(): #{
          self._movie.setStateStop()
        #}
      #}
      else: #{
        iren = self.ren.getIRen()
        self._animation = iren.CreateRepeatingTimer(100)
        iren.AddObserver('TimerEvent', self.animationLoop, 0.0)
        self._movie.setStateRun()
    else: #}{
      QtGui.QMessageBox.critical(self,
                   'Warning',
                   'Movie creation already active.',
                   QtGui.QMessageBox.Close)
      #}
    #}
      
  ###
  # \function  saveMovieFrame
  # \brief     Save a rendered image to a file with a path formed by the
  #            base path and an appended index counter.
  ###
  def saveMovieFrame(self): #{
    idx = self._movie.getFileIndex()
    base_path = self._movie.getFilename()
    if bool(base_path): #{
      base_dir = os.path.dirname(base_path)
      split_base_file = os.path.splitext(os.path.basename(base_path))
      path = base_dir + '/' + split_base_file[0] + \
             '_' + '{:08}'.format(idx) + split_base_file[1]
      self.ren.writeFrameToFile(path)
      self._movie.incFileIndex()
    #}
  #}

  ###
  # \function setBackground
  # \brief    Prompts the user for a color and then uses it to set the
  #           background colour of the render window.
  ###
  def setBackground(self): #{
    q_col = QtGui.QColorDialog.getColor()
    if q_col.isValid(): #{
      v_col = [q_col.red() / 255.0, q_col.green() / 255.0, q_col.blue() / 255.0]
      self.ren.getRen().SetBackground(v_col)
    #}
  #}

  def showTable(self): #{
    if self._actors.isVisible(): #{
      self._actors.hide()
    else: #}{
      self._actors.show()
    #}
  #}

  def goHome(self): #{
    if bool(self._home): #{
      self.ren.setView(self._home)
    #}
  #}

  def setHome(self): #{
    self._home = self.ren.getView()
    print(self._home)
  #}

  ###
  # \function  resetView
  # \brief     Resets the camera to make sure that all actors ar visible.
  ###
  def resetView(self): #{
    self.ren.getRen().ResetCamera()
    self.ren.Render()
  #}

  ###
  # \function  setActorVisible
  # \brief     Sets the actor visibility to the given state in both the actor
  #            table and the VTK render window.
  # \param idx                 Index of the actor in the actor table.
  # \param state               required visibility (boolean).
  ###
  def setActorVisible(self, idx, state): #{
    actor = self._actors.getActor(idx)
    actor.SetVisibility(state)
    self._actors.setActorVisible(idx, state)
    self.ren.Render()
  #}

  ###
  # \function  setActorColor
  # \brief     Sets the actor colour in both the actor table and the VTK
  #            render window.
  # \param idx                 Index of the actor in the actor table.
  # \param q_col               Colour in QColor form.
  ###
  def setActorColor(self, idx, q_col): #{
    actor = self._actors.getActor(idx)
    v_col = [q_col.red() / 255.0, q_col.green() / 255.0, q_col.blue() / 255.0]
    actor.GetProperty().SetDiffuseColor(v_col)
    self._actors.setActorColor(idx, q_col)
    self.ren.Render()
  #}

  ###
  # \function  setActorOpacity
  # \brief     Sets the actor opacity in both the actor table and the VTK
  #            render window.
  # \param idx                 Index of the actor in the actor table.
  # \param q_col               Opacity as a flaot, range [0.0-1.0].
  ###
  def setActorOpacity(self, idx, op): #{
    actor = self._actors.getActor(idx)
    actor.GetProperty().SetOpacity(op)
    self._actors.setActorOpacity(idx, op)
    self.ren.Render()
  #}

###
# \function  main
# \brief     Main function for the application which parses any command line
#            options then passes any files given on the command line to the
#            main application constructor.
###
def main(): #{
  app = QtGui.QApplication(sys.argv)
  parser = argparse.ArgumentParser(
      description='Interactive display of surfaces.',
      epilog='Supported surface formats are: ' +
             str(MAVTKSurfViewer._file_formats) + '.\n')
  parser.add_argument('-v', '--version',
      action='store_true', default=False, \
      help='Show version and exit.')
  parser.add_argument('file', nargs='*')
  args = parser.parse_args()
  if(args.version): #{
    print(MAVTKSurfViewer._version)
    sys.exit(0)
  #}
  sv = MAVTKSurfViewer(args.file)
  sys.exit(app.exec_())
#}


if __name__ == '__main__': #{
  main()
#}

